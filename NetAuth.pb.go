// Code generated by protoc-gen-go. DO NOT EDIT.
// source: NetAuth.proto

/*
Package Protocol is a generated protocol buffer package.

It is generated from these files:
	NetAuth.proto

It has these top-level messages:
	ClientInfo
	NetAuthRequest
	ModEntityRequest
	ModEntityKeyRequest
	ModEntityMembershipRequest
	Entity
	SimpleResult
	TokenResult
	KeyList
	Group
	ModGroupRequest
	GroupMemberRequest
	GroupListRequest
	GroupList
	GroupInfoResult
	EntityMeta
	EntityList
	ModGroupNestingRequest
	ModCapabilityRequest
	PingRequest
	PingResponse
*/
package Protocol

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Capabilities permit the holder to perform special actions within
// NetAuth.  This allows the holder to do things related to management
// of the server without needing to use the GLOBAL_ROOT bootstrap
// user.
type Capability int32

const (
	Capability_GLOBAL_ROOT          Capability = 0
	Capability_CREATE_ENTITY        Capability = 10
	Capability_DESTORY_ENTITY       Capability = 11
	Capability_MODIFY_ENTITY_META   Capability = 12
	Capability_MODIFY_ENTITY_KEYS   Capability = 13
	Capability_CHANGE_ENTITY_SECRET Capability = 14
	Capability_CREATE_GROUP         Capability = 20
	Capability_DESTROY_GROUP        Capability = 21
	Capability_MODIFY_GROUP_META    Capability = 22
	Capability_MODIFY_GROUP_MEMBERS Capability = 23
)

var Capability_name = map[int32]string{
	0:  "GLOBAL_ROOT",
	10: "CREATE_ENTITY",
	11: "DESTORY_ENTITY",
	12: "MODIFY_ENTITY_META",
	13: "MODIFY_ENTITY_KEYS",
	14: "CHANGE_ENTITY_SECRET",
	20: "CREATE_GROUP",
	21: "DESTROY_GROUP",
	22: "MODIFY_GROUP_META",
	23: "MODIFY_GROUP_MEMBERS",
}
var Capability_value = map[string]int32{
	"GLOBAL_ROOT":          0,
	"CREATE_ENTITY":        10,
	"DESTORY_ENTITY":       11,
	"MODIFY_ENTITY_META":   12,
	"MODIFY_ENTITY_KEYS":   13,
	"CHANGE_ENTITY_SECRET": 14,
	"CREATE_GROUP":         20,
	"DESTROY_GROUP":        21,
	"MODIFY_GROUP_META":    22,
	"MODIFY_GROUP_MEMBERS": 23,
}

func (x Capability) Enum() *Capability {
	p := new(Capability)
	*p = x
	return p
}
func (x Capability) String() string {
	return proto.EnumName(Capability_name, int32(x))
}
func (x *Capability) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Capability_value, data, "Capability")
	if err != nil {
		return err
	}
	*x = Capability(value)
	return nil
}
func (Capability) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Group expansions can either be to include children of the named
// group, or to exclude them.
type ExpansionMode int32

const (
	ExpansionMode_INCLUDE ExpansionMode = 1
	ExpansionMode_EXCLUDE ExpansionMode = 2
	ExpansionMode_DROP    ExpansionMode = 99
)

var ExpansionMode_name = map[int32]string{
	1:  "INCLUDE",
	2:  "EXCLUDE",
	99: "DROP",
}
var ExpansionMode_value = map[string]int32{
	"INCLUDE": 1,
	"EXCLUDE": 2,
	"DROP":    99,
}

func (x ExpansionMode) Enum() *ExpansionMode {
	p := new(ExpansionMode)
	*p = x
	return p
}
func (x ExpansionMode) String() string {
	return proto.EnumName(ExpansionMode_name, int32(x))
}
func (x *ExpansionMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ExpansionMode_value, data, "ExpansionMode")
	if err != nil {
		return err
	}
	*x = ExpansionMode(value)
	return nil
}
func (ExpansionMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// The ClientInfo message contains information about the client
// originating the request.  This information must not be used for
// security functions of any kind, as it is directly editable by the
// client.
type ClientInfo struct {
	// The ID is to be used to define the originating client, this
	// should in general be set to the client's hostname, or otherwise
	// some persistent system identifier.
	ID *string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	// The Service is an identifier that defined what is asking the
	// system for information.  This should usually be set to the
	// application name, or 'SYSTEM' if the request is on behalf of the
	// system itself.
	Service          *string `protobuf:"bytes,2,opt,name=Service" json:"Service,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ClientInfo) Reset()                    { *m = ClientInfo{} }
func (m *ClientInfo) String() string            { return proto.CompactTextString(m) }
func (*ClientInfo) ProtoMessage()               {}
func (*ClientInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ClientInfo) GetID() string {
	if m != nil && m.ID != nil {
		return *m.ID
	}
	return ""
}

func (m *ClientInfo) GetService() string {
	if m != nil && m.Service != nil {
		return *m.Service
	}
	return ""
}

// An AuthRequest includes an Entity and some information to identify
// the system that is making the request.
type NetAuthRequest struct {
	// The Entity is obviously the most important part of the
	// AuthRequest which is the thing we want to authenticate.
	Entity    *Entity `protobuf:"bytes,1,req,name=Entity" json:"Entity,omitempty"`
	AuthToken *string `protobuf:"bytes,2,opt,name=AuthToken" json:"AuthToken,omitempty"`
	// Client information for logging
	Info             *ClientInfo `protobuf:"bytes,3,opt,name=Info" json:"Info,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *NetAuthRequest) Reset()                    { *m = NetAuthRequest{} }
func (m *NetAuthRequest) String() string            { return proto.CompactTextString(m) }
func (*NetAuthRequest) ProtoMessage()               {}
func (*NetAuthRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *NetAuthRequest) GetEntity() *Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *NetAuthRequest) GetAuthToken() string {
	if m != nil && m.AuthToken != nil {
		return *m.AuthToken
	}
	return ""
}

func (m *NetAuthRequest) GetInfo() *ClientInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

// A ModEntityRequest takes an entity to authorize and an entity to
// act upon.  These may be the same entity for changes being applied
// by an entity to itself.
type ModEntityRequest struct {
	// The request must always have an entity, the second entity may not
	// be set in which case the first entity will be acted upon.
	Entity *Entity `protobuf:"bytes,1,req,name=Entity" json:"Entity,omitempty"`
	// This is the entity to act on, it may be set or it may not be.
	ModEntity *Entity `protobuf:"bytes,2,opt,name=ModEntity" json:"ModEntity,omitempty"`
	// Client information for logging
	Info *ClientInfo `protobuf:"bytes,3,opt,name=Info" json:"Info,omitempty"`
	// The authentication token is used to authorize changes made to the
	// state of things in the NetAuth database.
	AuthToken        *string `protobuf:"bytes,4,req,name=AuthToken" json:"AuthToken,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ModEntityRequest) Reset()                    { *m = ModEntityRequest{} }
func (m *ModEntityRequest) String() string            { return proto.CompactTextString(m) }
func (*ModEntityRequest) ProtoMessage()               {}
func (*ModEntityRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ModEntityRequest) GetEntity() *Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *ModEntityRequest) GetModEntity() *Entity {
	if m != nil {
		return m.ModEntity
	}
	return nil
}

func (m *ModEntityRequest) GetInfo() *ClientInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *ModEntityRequest) GetAuthToken() string {
	if m != nil && m.AuthToken != nil {
		return *m.AuthToken
	}
	return ""
}

// Modify the keys for a given entity
type ModEntityKeyRequest struct {
	// The request must have an entity and token to authorize the
	// change, from there it may have a mode, type, and key, but these
	// are not required.
	Entity    *Entity     `protobuf:"bytes,1,req,name=Entity" json:"Entity,omitempty"`
	AuthToken *string     `protobuf:"bytes,2,req,name=AuthToken" json:"AuthToken,omitempty"`
	Info      *ClientInfo `protobuf:"bytes,3,opt,name=Info" json:"Info,omitempty"`
	// Contents for the key change itself
	Mode             *string `protobuf:"bytes,4,opt,name=Mode" json:"Mode,omitempty"`
	Type             *string `protobuf:"bytes,5,opt,name=Type" json:"Type,omitempty"`
	Key              *string `protobuf:"bytes,6,opt,name=Key" json:"Key,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ModEntityKeyRequest) Reset()                    { *m = ModEntityKeyRequest{} }
func (m *ModEntityKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*ModEntityKeyRequest) ProtoMessage()               {}
func (*ModEntityKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ModEntityKeyRequest) GetEntity() *Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *ModEntityKeyRequest) GetAuthToken() string {
	if m != nil && m.AuthToken != nil {
		return *m.AuthToken
	}
	return ""
}

func (m *ModEntityKeyRequest) GetInfo() *ClientInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *ModEntityKeyRequest) GetMode() string {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return ""
}

func (m *ModEntityKeyRequest) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *ModEntityKeyRequest) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

type ModEntityMembershipRequest struct {
	// The entity in question
	Entity *Entity `protobuf:"bytes,1,req,name=entity" json:"entity,omitempty"`
	// The group that is being added or removed is taken as a group name
	Group *Group `protobuf:"bytes,3,req,name=Group" json:"Group,omitempty"`
	// Client information for logging
	Info *ClientInfo `protobuf:"bytes,4,opt,name=Info" json:"Info,omitempty"`
	// The authentication token is used to authorize changes made to the
	// state of things in the NetAuth database.
	AuthToken        *string `protobuf:"bytes,5,req,name=AuthToken" json:"AuthToken,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ModEntityMembershipRequest) Reset()                    { *m = ModEntityMembershipRequest{} }
func (m *ModEntityMembershipRequest) String() string            { return proto.CompactTextString(m) }
func (*ModEntityMembershipRequest) ProtoMessage()               {}
func (*ModEntityMembershipRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ModEntityMembershipRequest) GetEntity() *Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *ModEntityMembershipRequest) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *ModEntityMembershipRequest) GetInfo() *ClientInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *ModEntityMembershipRequest) GetAuthToken() string {
	if m != nil && m.AuthToken != nil {
		return *m.AuthToken
	}
	return ""
}

// An entity may be a person or a machine actor that wishes to act as
// some identity.  To do so they will need to transmit an ID and a
// secret which will be used to verify that they are who they say they
// are.
type Entity struct {
	// The entity may be identified by a string.  This is most common
	// for the initial authentication case where a people-entity has
	// typed a name in and now wishes to be authenticated.
	ID *string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	// An entity might also be identified by a unique ID number.  This
	// case is most common when some program wishes to get information
	// about an entity.
	Number *int32 `protobuf:"varint,2,opt,name=Number" json:"Number,omitempty"`
	// The entity may have a secret which they will use to authenticate
	// themselves.
	Secret *string `protobuf:"bytes,3,opt,name=secret" json:"secret,omitempty"`
	// For requests that update the meta information this must be
	// attatched to the entity itself.  This also allows the in-memory
	// format to be defined by this proto.
	Meta             *EntityMeta `protobuf:"bytes,4,opt,name=meta" json:"meta,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Entity) Reset()                    { *m = Entity{} }
func (m *Entity) String() string            { return proto.CompactTextString(m) }
func (*Entity) ProtoMessage()               {}
func (*Entity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Entity) GetID() string {
	if m != nil && m.ID != nil {
		return *m.ID
	}
	return ""
}

func (m *Entity) GetNumber() int32 {
	if m != nil && m.Number != nil {
		return *m.Number
	}
	return 0
}

func (m *Entity) GetSecret() string {
	if m != nil && m.Secret != nil {
		return *m.Secret
	}
	return ""
}

func (m *Entity) GetMeta() *EntityMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

// A SimpleResult can be returned from most services and explains
// whether or not the service completed successfully or not, and an
// optional message that may explain in more detail.
type SimpleResult struct {
	// Required is forever, but a SimpleResult without a success state
	// doesn't mean much.  This field must be present in all replies.
	Success *bool `protobuf:"varint,1,req,name=success,def=0" json:"success,omitempty"`
	// In the failure case a message may be provided detailing the
	// failure.  This message must not contain secure information and
	// there must be an expectation that anything placed in this field
	// will be shown directly to a person or written to a log.
	Msg              *string `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SimpleResult) Reset()                    { *m = SimpleResult{} }
func (m *SimpleResult) String() string            { return proto.CompactTextString(m) }
func (*SimpleResult) ProtoMessage()               {}
func (*SimpleResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

const Default_SimpleResult_Success bool = false

func (m *SimpleResult) GetSuccess() bool {
	if m != nil && m.Success != nil {
		return *m.Success
	}
	return Default_SimpleResult_Success
}

func (m *SimpleResult) GetMsg() string {
	if m != nil && m.Msg != nil {
		return *m.Msg
	}
	return ""
}

// A token reply will include the status of the authentication
// request, and if successful, an authentication token that can be
// used for future requests.
type TokenResult struct {
	// Success will provide a high level status of if the reply
	// succeeded.
	Success *bool `protobuf:"varint,1,req,name=success,def=0" json:"success,omitempty"`
	// Msg contains information about a failure if applicable.
	Msg *string `protobuf:"bytes,2,opt,name=Msg" json:"Msg,omitempty"`
	// Token contains the token if the request was successful or is
	// empty otherwise.
	Token            *string `protobuf:"bytes,3,opt,name=Token" json:"Token,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TokenResult) Reset()                    { *m = TokenResult{} }
func (m *TokenResult) String() string            { return proto.CompactTextString(m) }
func (*TokenResult) ProtoMessage()               {}
func (*TokenResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

const Default_TokenResult_Success bool = false

func (m *TokenResult) GetSuccess() bool {
	if m != nil && m.Success != nil {
		return *m.Success
	}
	return Default_TokenResult_Success
}

func (m *TokenResult) GetMsg() string {
	if m != nil && m.Msg != nil {
		return *m.Msg
	}
	return ""
}

func (m *TokenResult) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

// A KeyList is a list of keys.
type KeyList struct {
	Keys             []string `protobuf:"bytes,1,rep,name=Keys" json:"Keys,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *KeyList) Reset()                    { *m = KeyList{} }
func (m *KeyList) String() string            { return proto.CompactTextString(m) }
func (*KeyList) ProtoMessage()               {}
func (*KeyList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *KeyList) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

// While machine entities may belong to only one group, people
// entities often belong to many groups at once.  This message
// structures the reply for the additional groups.
type Group struct {
	// A group name must satisfy the requirements of the UNIX group
	// naming conventions.  This should be one word, lower case, with no
	// spaces and cannot begin with a number.
	Name *string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	// Since the name has strict naming requirements, its nice to have a
	// displayName for the group which has a more friendly display.
	// Instead of trying to reason out what naacct means, its much nicer
	// to just know that its "Accounting team - North America"
	DisplayName *string `protobuf:"bytes,2,opt,name=DisplayName" json:"DisplayName,omitempty"`
	// On *nix systems the group should also have a number.  This number
	// should be the same across all systems since it may be used for
	// internal matching of users.
	Number *int32 `protobuf:"varint,3,opt,name=Number" json:"Number,omitempty"`
	// Groups can be managed by other groups.  For a group to be self
	// managed, one would set the managed by group to be the group
	// itself.
	ManagedBy *string `protobuf:"bytes,5,opt,name=ManagedBy" json:"ManagedBy,omitempty"`
	// Groups may have capabilities that are conferred to members of the
	// group on a membership basis.  This is the preferred way of
	// granting capabilities to an entity since it means that when an
	// entity is removed from the group they lose the capabilities that
	// were granted from it.
	Capabilities []Capability `protobuf:"varint,50,rep,name=Capabilities,enum=Capability" json:"Capabilities,omitempty"`
	// Groups can also be members of other groups.  This allows a group
	// to appear to contain a larger membership and build this
	// membership based on potentially very intricate include/exclude
	// rules.  The format of this field is "<mode>:<group>" so if you
	// were including the membership of 'foo', then it would have the
	// value of "INCLUDE:foo".
	Expansions       []string `protobuf:"bytes,51,rep,name=Expansions" json:"Expansions,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Group) Reset()                    { *m = Group{} }
func (m *Group) String() string            { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()               {}
func (*Group) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Group) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Group) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *Group) GetNumber() int32 {
	if m != nil && m.Number != nil {
		return *m.Number
	}
	return 0
}

func (m *Group) GetManagedBy() string {
	if m != nil && m.ManagedBy != nil {
		return *m.ManagedBy
	}
	return ""
}

func (m *Group) GetCapabilities() []Capability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

func (m *Group) GetExpansions() []string {
	if m != nil {
		return m.Expansions
	}
	return nil
}

type ModGroupRequest struct {
	// The AuthToken for authorization of changes to the database.
	AuthToken *string `protobuf:"bytes,1,req,name=AuthToken" json:"AuthToken,omitempty"`
	// The group that's being modified.
	Group *Group `protobuf:"bytes,2,req,name=Group" json:"Group,omitempty"`
	// Client information for logging
	Info             *ClientInfo `protobuf:"bytes,3,opt,name=Info" json:"Info,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *ModGroupRequest) Reset()                    { *m = ModGroupRequest{} }
func (m *ModGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*ModGroupRequest) ProtoMessage()               {}
func (*ModGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ModGroupRequest) GetAuthToken() string {
	if m != nil && m.AuthToken != nil {
		return *m.AuthToken
	}
	return ""
}

func (m *ModGroupRequest) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *ModGroupRequest) GetInfo() *ClientInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

type GroupMemberRequest struct {
	// The group for which info is being requested.
	Group *Group `protobuf:"bytes,1,opt,name=Group" json:"Group,omitempty"`
	// Client information for logging
	Info             *ClientInfo `protobuf:"bytes,2,opt,name=Info" json:"Info,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *GroupMemberRequest) Reset()                    { *m = GroupMemberRequest{} }
func (m *GroupMemberRequest) String() string            { return proto.CompactTextString(m) }
func (*GroupMemberRequest) ProtoMessage()               {}
func (*GroupMemberRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *GroupMemberRequest) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *GroupMemberRequest) GetInfo() *ClientInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

type GroupListRequest struct {
	Info             *ClientInfo `protobuf:"bytes,1,opt,name=Info" json:"Info,omitempty"`
	Entity           *Entity     `protobuf:"bytes,2,opt,name=Entity" json:"Entity,omitempty"`
	IncludeIndirects *bool       `protobuf:"varint,3,opt,name=IncludeIndirects,def=1" json:"IncludeIndirects,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *GroupListRequest) Reset()                    { *m = GroupListRequest{} }
func (m *GroupListRequest) String() string            { return proto.CompactTextString(m) }
func (*GroupListRequest) ProtoMessage()               {}
func (*GroupListRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

const Default_GroupListRequest_IncludeIndirects bool = true

func (m *GroupListRequest) GetInfo() *ClientInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *GroupListRequest) GetEntity() *Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *GroupListRequest) GetIncludeIndirects() bool {
	if m != nil && m.IncludeIndirects != nil {
		return *m.IncludeIndirects
	}
	return Default_GroupListRequest_IncludeIndirects
}

type GroupList struct {
	Groups           []*Group `protobuf:"bytes,1,rep,name=Groups" json:"Groups,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GroupList) Reset()                    { *m = GroupList{} }
func (m *GroupList) String() string            { return proto.CompactTextString(m) }
func (*GroupList) ProtoMessage()               {}
func (*GroupList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *GroupList) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type GroupInfoResult struct {
	Group            *Group   `protobuf:"bytes,1,req,name=Group" json:"Group,omitempty"`
	Managed          []string `protobuf:"bytes,2,rep,name=Managed" json:"Managed,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GroupInfoResult) Reset()                    { *m = GroupInfoResult{} }
func (m *GroupInfoResult) String() string            { return proto.CompactTextString(m) }
func (*GroupInfoResult) ProtoMessage()               {}
func (*GroupInfoResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *GroupInfoResult) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *GroupInfoResult) GetManaged() []string {
	if m != nil {
		return m.Managed
	}
	return nil
}

type EntityMeta struct {
	// The primary group ID for the entity.  On most UNIX systems this
	// will map to a group with the same string representation as the
	// Entity, but it is not uncommon for people-entities in a network
	// environment to not have a personal primary group and instead
	// belong to an organization wide primary group.
	Pgid *Group `protobuf:"bytes,1,opt,name=pgid" json:"pgid,omitempty"`
	// This is an arbitrary field used to store things like the user's
	// real name.  It is here for consistency, but the name displayed by
	// the user should really be stored in displayName, with the actual
	// name stored in legalName (this facilitates a user to have an
	// arbitrary name displayed if this is permitted by local policy).
	GECOS *string `protobuf:"bytes,2,opt,name=GECOS" json:"GECOS,omitempty"`
	// This stores the legal name (if used) that owns this security
	// entity.  This primarily here for places where knowing the single
	// owning entity is a requirement for compliance reasons.
	LegalName *string `protobuf:"bytes,3,opt,name=LegalName" json:"LegalName,omitempty"`
	// This field is for the display value of the legalName.  This lets
	// the displayed value fluctuate with no connection to the actual
	// identity of the owning entity.
	DisplayName *string `protobuf:"bytes,4,opt,name=DisplayName" json:"DisplayName,omitempty"`
	// Given that the entity identity and auth are provided by the
	// network, its not unlikely that the home directory for the entity
	// is as well.  This string contains the fully qualified path to the
	// home directory.
	Home *string `protobuf:"bytes,5,opt,name=Home" json:"Home,omitempty"`
	// This string is the canonical 'user command interpreter' specified
	// in the passwd file.  This value provided by this field must be
	// safe to use on all target systems as setting this to something
	// that doesn't exist on the targets will cause the login program to
	// abort when setting up the environment.
	Shell *string `protobuf:"bytes,6,opt,name=Shell" json:"Shell,omitempty"`
	// This is for the graphical shell, primarily for when the entity is
	// a person (though machine entities might also need to have a
	// graphical shell set).  This provides a handy place to store it,
	// but unfortunately a seperate mechanism is needed to get this into
	// the systems that actually setup the graphical environment.
	GraphicalShell *string `protobuf:"bytes,7,opt,name=GraphicalShell" json:"GraphicalShell,omitempty"`
	// Person entities may have a physical badge which gets them access
	// to things, and machine entities may have an asset tag which is
	// nice to keep track of.  This is a string rather than a number
	// because the badge "number" might actually be a UUID or something
	// that is not otherwise a pure number.
	BadgeNumber *string `protobuf:"bytes,8,opt,name=BadgeNumber" json:"BadgeNumber,omitempty"`
	// Entities may be direct members of groups
	Groups []string `protobuf:"bytes,250,rep,name=Groups" json:"Groups,omitempty"`
	// Entities may have capabilities that provide special actions to
	// the holder within NetAuth.
	Capabilities []Capability `protobuf:"varint,251,rep,name=Capabilities,enum=Capability" json:"Capabilities,omitempty"`
	// Entities may also have one or more Keys associated with them.
	// This is deliberately untyped to allow it to be TYPE:KEY rather
	// than needing a protocol update every time a new type of key
	// should be stored.
	Keys             []string `protobuf:"bytes,252,rep,name=Keys" json:"Keys,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EntityMeta) Reset()                    { *m = EntityMeta{} }
func (m *EntityMeta) String() string            { return proto.CompactTextString(m) }
func (*EntityMeta) ProtoMessage()               {}
func (*EntityMeta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *EntityMeta) GetPgid() *Group {
	if m != nil {
		return m.Pgid
	}
	return nil
}

func (m *EntityMeta) GetGECOS() string {
	if m != nil && m.GECOS != nil {
		return *m.GECOS
	}
	return ""
}

func (m *EntityMeta) GetLegalName() string {
	if m != nil && m.LegalName != nil {
		return *m.LegalName
	}
	return ""
}

func (m *EntityMeta) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *EntityMeta) GetHome() string {
	if m != nil && m.Home != nil {
		return *m.Home
	}
	return ""
}

func (m *EntityMeta) GetShell() string {
	if m != nil && m.Shell != nil {
		return *m.Shell
	}
	return ""
}

func (m *EntityMeta) GetGraphicalShell() string {
	if m != nil && m.GraphicalShell != nil {
		return *m.GraphicalShell
	}
	return ""
}

func (m *EntityMeta) GetBadgeNumber() string {
	if m != nil && m.BadgeNumber != nil {
		return *m.BadgeNumber
	}
	return ""
}

func (m *EntityMeta) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *EntityMeta) GetCapabilities() []Capability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

func (m *EntityMeta) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

// GroupMemberList is returned when a query generates a list of
// entities.
type EntityList struct {
	Members          []*Entity `protobuf:"bytes,1,rep,name=Members" json:"Members,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *EntityList) Reset()                    { *m = EntityList{} }
func (m *EntityList) String() string            { return proto.CompactTextString(m) }
func (*EntityList) ProtoMessage()               {}
func (*EntityList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *EntityList) GetMembers() []*Entity {
	if m != nil {
		return m.Members
	}
	return nil
}

// ModGroupNestingRequest handles the addition or removal of group
// nesting operations.
type ModGroupNestingRequest struct {
	// This action must be authorized
	AuthToken *string `protobuf:"bytes,1,req,name=AuthToken" json:"AuthToken,omitempty"`
	// There must be a parent and child group for each request.
	ParentGroup *Group `protobuf:"bytes,2,req,name=ParentGroup" json:"ParentGroup,omitempty"`
	ChildGroup  *Group `protobuf:"bytes,3,req,name=ChildGroup" json:"ChildGroup,omitempty"`
	// Expansions can either include children or exclude them.  The
	// default is to include.
	Mode *ExpansionMode `protobuf:"varint,4,opt,name=Mode,enum=ExpansionMode" json:"Mode,omitempty"`
	// Like other requests this contains info about the caller
	Info             *ClientInfo `protobuf:"bytes,5,opt,name=Info" json:"Info,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *ModGroupNestingRequest) Reset()                    { *m = ModGroupNestingRequest{} }
func (m *ModGroupNestingRequest) String() string            { return proto.CompactTextString(m) }
func (*ModGroupNestingRequest) ProtoMessage()               {}
func (*ModGroupNestingRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ModGroupNestingRequest) GetAuthToken() string {
	if m != nil && m.AuthToken != nil {
		return *m.AuthToken
	}
	return ""
}

func (m *ModGroupNestingRequest) GetParentGroup() *Group {
	if m != nil {
		return m.ParentGroup
	}
	return nil
}

func (m *ModGroupNestingRequest) GetChildGroup() *Group {
	if m != nil {
		return m.ChildGroup
	}
	return nil
}

func (m *ModGroupNestingRequest) GetMode() ExpansionMode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return ExpansionMode_INCLUDE
}

func (m *ModGroupNestingRequest) GetInfo() *ClientInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

type ModCapabilityRequest struct {
	// This action must be authorized
	AuthToken *string `protobuf:"bytes,1,req,name=AuthToken" json:"AuthToken,omitempty"`
	// Either an entity or a group must be specified, if both are
	// specified, the group will be ignored.
	Entity *Entity `protobuf:"bytes,2,opt,name=Entity" json:"Entity,omitempty"`
	Group  *Group  `protobuf:"bytes,3,opt,name=Group" json:"Group,omitempty"`
	// The mode can be either 'ADD' or 'REMOVE'
	Mode *string `protobuf:"bytes,4,req,name=Mode" json:"Mode,omitempty"`
	// And of course, the capability must be specified
	Capability *Capability `protobuf:"varint,5,req,name=Capability,enum=Capability" json:"Capability,omitempty"`
	// Like other requests this contains info about the caller
	Info             *ClientInfo `protobuf:"bytes,6,opt,name=Info" json:"Info,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *ModCapabilityRequest) Reset()                    { *m = ModCapabilityRequest{} }
func (m *ModCapabilityRequest) String() string            { return proto.CompactTextString(m) }
func (*ModCapabilityRequest) ProtoMessage()               {}
func (*ModCapabilityRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ModCapabilityRequest) GetAuthToken() string {
	if m != nil && m.AuthToken != nil {
		return *m.AuthToken
	}
	return ""
}

func (m *ModCapabilityRequest) GetEntity() *Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *ModCapabilityRequest) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *ModCapabilityRequest) GetMode() string {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return ""
}

func (m *ModCapabilityRequest) GetCapability() Capability {
	if m != nil && m.Capability != nil {
		return *m.Capability
	}
	return Capability_GLOBAL_ROOT
}

func (m *ModCapabilityRequest) GetInfo() *ClientInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

// The PingRequest is used to ask the server to return its health
// status to the requestor.
type PingRequest struct {
	// Client information for logging
	Info             *ClientInfo `protobuf:"bytes,1,opt,name=Info" json:"Info,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *PingRequest) Reset()                    { *m = PingRequest{} }
func (m *PingRequest) String() string            { return proto.CompactTextString(m) }
func (*PingRequest) ProtoMessage()               {}
func (*PingRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *PingRequest) GetInfo() *ClientInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

// The PingReply is used to tell the client if this server is healthy
// and ready to serve.
type PingResponse struct {
	// The server will reply healthy=True if it is ready to serve.
	Healthy *bool `protobuf:"varint,1,opt,name=Healthy" json:"Healthy,omitempty"`
	// Optionally the server may have a message if it is not healthy.
	Msg              *string `protobuf:"bytes,2,opt,name=Msg" json:"Msg,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PingResponse) Reset()                    { *m = PingResponse{} }
func (m *PingResponse) String() string            { return proto.CompactTextString(m) }
func (*PingResponse) ProtoMessage()               {}
func (*PingResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *PingResponse) GetHealthy() bool {
	if m != nil && m.Healthy != nil {
		return *m.Healthy
	}
	return false
}

func (m *PingResponse) GetMsg() string {
	if m != nil && m.Msg != nil {
		return *m.Msg
	}
	return ""
}

func init() {
	proto.RegisterType((*ClientInfo)(nil), "ClientInfo")
	proto.RegisterType((*NetAuthRequest)(nil), "NetAuthRequest")
	proto.RegisterType((*ModEntityRequest)(nil), "ModEntityRequest")
	proto.RegisterType((*ModEntityKeyRequest)(nil), "ModEntityKeyRequest")
	proto.RegisterType((*ModEntityMembershipRequest)(nil), "ModEntityMembershipRequest")
	proto.RegisterType((*Entity)(nil), "Entity")
	proto.RegisterType((*SimpleResult)(nil), "SimpleResult")
	proto.RegisterType((*TokenResult)(nil), "TokenResult")
	proto.RegisterType((*KeyList)(nil), "KeyList")
	proto.RegisterType((*Group)(nil), "Group")
	proto.RegisterType((*ModGroupRequest)(nil), "ModGroupRequest")
	proto.RegisterType((*GroupMemberRequest)(nil), "GroupMemberRequest")
	proto.RegisterType((*GroupListRequest)(nil), "GroupListRequest")
	proto.RegisterType((*GroupList)(nil), "GroupList")
	proto.RegisterType((*GroupInfoResult)(nil), "GroupInfoResult")
	proto.RegisterType((*EntityMeta)(nil), "EntityMeta")
	proto.RegisterType((*EntityList)(nil), "EntityList")
	proto.RegisterType((*ModGroupNestingRequest)(nil), "ModGroupNestingRequest")
	proto.RegisterType((*ModCapabilityRequest)(nil), "ModCapabilityRequest")
	proto.RegisterType((*PingRequest)(nil), "PingRequest")
	proto.RegisterType((*PingResponse)(nil), "PingResponse")
	proto.RegisterEnum("Capability", Capability_name, Capability_value)
	proto.RegisterEnum("ExpansionMode", ExpansionMode_name, ExpansionMode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for NetAuth service

type NetAuthClient interface {
	// It is desireable to ping the server for status and health
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	// AuthEntity and GetToken both verify that an entity is who they
	// claim to be (or at least that they posses the identifying
	// information) with the only difference being that GetToken will
	// unsurprisingly return a token on success.
	AuthEntity(ctx context.Context, in *NetAuthRequest, opts ...grpc.CallOption) (*SimpleResult, error)
	GetToken(ctx context.Context, in *NetAuthRequest, opts ...grpc.CallOption) (*TokenResult, error)
	ValidateToken(ctx context.Context, in *NetAuthRequest, opts ...grpc.CallOption) (*SimpleResult, error)
	// ChangeSecret is unusual in that it uses the token if vouching for
	// *another* entity's secret being changed, but if the change is for
	// the requesting entity, the original secret must be provided.
	ChangeSecret(ctx context.Context, in *ModEntityRequest, opts ...grpc.CallOption) (*SimpleResult, error)
	// AssignCapability assigns or removes capabilities on an entity or
	// a group.
	ManageCapabilities(ctx context.Context, in *ModCapabilityRequest, opts ...grpc.CallOption) (*SimpleResult, error)
	// Add and remove Entities
	NewEntity(ctx context.Context, in *ModEntityRequest, opts ...grpc.CallOption) (*SimpleResult, error)
	RemoveEntity(ctx context.Context, in *ModEntityRequest, opts ...grpc.CallOption) (*SimpleResult, error)
	// Get and set meta information about entities
	EntityInfo(ctx context.Context, in *NetAuthRequest, opts ...grpc.CallOption) (*Entity, error)
	ModifyEntityMeta(ctx context.Context, in *ModEntityRequest, opts ...grpc.CallOption) (*SimpleResult, error)
	ModifyEntityKeys(ctx context.Context, in *ModEntityKeyRequest, opts ...grpc.CallOption) (*KeyList, error)
	// Add, Remove, and Modify groups
	NewGroup(ctx context.Context, in *ModGroupRequest, opts ...grpc.CallOption) (*SimpleResult, error)
	DeleteGroup(ctx context.Context, in *ModGroupRequest, opts ...grpc.CallOption) (*SimpleResult, error)
	ModifyGroupMeta(ctx context.Context, in *ModGroupRequest, opts ...grpc.CallOption) (*SimpleResult, error)
	GroupInfo(ctx context.Context, in *ModGroupRequest, opts ...grpc.CallOption) (*GroupInfoResult, error)
	// List groups and members
	ListGroups(ctx context.Context, in *GroupListRequest, opts ...grpc.CallOption) (*GroupList, error)
	ListGroupMembers(ctx context.Context, in *GroupMemberRequest, opts ...grpc.CallOption) (*EntityList, error)
	// Modify direct group membership
	AddEntityToGroup(ctx context.Context, in *ModEntityMembershipRequest, opts ...grpc.CallOption) (*SimpleResult, error)
	RemoveEntityFromGroup(ctx context.Context, in *ModEntityMembershipRequest, opts ...grpc.CallOption) (*SimpleResult, error)
	// Modify nested group membership
	ModifyGroupNesting(ctx context.Context, in *ModGroupNestingRequest, opts ...grpc.CallOption) (*SimpleResult, error)
}

type netAuthClient struct {
	cc *grpc.ClientConn
}

func NewNetAuthClient(cc *grpc.ClientConn) NetAuthClient {
	return &netAuthClient{cc}
}

func (c *netAuthClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := grpc.Invoke(ctx, "/NetAuth/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) AuthEntity(ctx context.Context, in *NetAuthRequest, opts ...grpc.CallOption) (*SimpleResult, error) {
	out := new(SimpleResult)
	err := grpc.Invoke(ctx, "/NetAuth/AuthEntity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) GetToken(ctx context.Context, in *NetAuthRequest, opts ...grpc.CallOption) (*TokenResult, error) {
	out := new(TokenResult)
	err := grpc.Invoke(ctx, "/NetAuth/GetToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) ValidateToken(ctx context.Context, in *NetAuthRequest, opts ...grpc.CallOption) (*SimpleResult, error) {
	out := new(SimpleResult)
	err := grpc.Invoke(ctx, "/NetAuth/ValidateToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) ChangeSecret(ctx context.Context, in *ModEntityRequest, opts ...grpc.CallOption) (*SimpleResult, error) {
	out := new(SimpleResult)
	err := grpc.Invoke(ctx, "/NetAuth/ChangeSecret", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) ManageCapabilities(ctx context.Context, in *ModCapabilityRequest, opts ...grpc.CallOption) (*SimpleResult, error) {
	out := new(SimpleResult)
	err := grpc.Invoke(ctx, "/NetAuth/ManageCapabilities", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) NewEntity(ctx context.Context, in *ModEntityRequest, opts ...grpc.CallOption) (*SimpleResult, error) {
	out := new(SimpleResult)
	err := grpc.Invoke(ctx, "/NetAuth/NewEntity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) RemoveEntity(ctx context.Context, in *ModEntityRequest, opts ...grpc.CallOption) (*SimpleResult, error) {
	out := new(SimpleResult)
	err := grpc.Invoke(ctx, "/NetAuth/RemoveEntity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) EntityInfo(ctx context.Context, in *NetAuthRequest, opts ...grpc.CallOption) (*Entity, error) {
	out := new(Entity)
	err := grpc.Invoke(ctx, "/NetAuth/EntityInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) ModifyEntityMeta(ctx context.Context, in *ModEntityRequest, opts ...grpc.CallOption) (*SimpleResult, error) {
	out := new(SimpleResult)
	err := grpc.Invoke(ctx, "/NetAuth/ModifyEntityMeta", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) ModifyEntityKeys(ctx context.Context, in *ModEntityKeyRequest, opts ...grpc.CallOption) (*KeyList, error) {
	out := new(KeyList)
	err := grpc.Invoke(ctx, "/NetAuth/ModifyEntityKeys", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) NewGroup(ctx context.Context, in *ModGroupRequest, opts ...grpc.CallOption) (*SimpleResult, error) {
	out := new(SimpleResult)
	err := grpc.Invoke(ctx, "/NetAuth/NewGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) DeleteGroup(ctx context.Context, in *ModGroupRequest, opts ...grpc.CallOption) (*SimpleResult, error) {
	out := new(SimpleResult)
	err := grpc.Invoke(ctx, "/NetAuth/DeleteGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) ModifyGroupMeta(ctx context.Context, in *ModGroupRequest, opts ...grpc.CallOption) (*SimpleResult, error) {
	out := new(SimpleResult)
	err := grpc.Invoke(ctx, "/NetAuth/ModifyGroupMeta", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) GroupInfo(ctx context.Context, in *ModGroupRequest, opts ...grpc.CallOption) (*GroupInfoResult, error) {
	out := new(GroupInfoResult)
	err := grpc.Invoke(ctx, "/NetAuth/GroupInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) ListGroups(ctx context.Context, in *GroupListRequest, opts ...grpc.CallOption) (*GroupList, error) {
	out := new(GroupList)
	err := grpc.Invoke(ctx, "/NetAuth/ListGroups", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) ListGroupMembers(ctx context.Context, in *GroupMemberRequest, opts ...grpc.CallOption) (*EntityList, error) {
	out := new(EntityList)
	err := grpc.Invoke(ctx, "/NetAuth/ListGroupMembers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) AddEntityToGroup(ctx context.Context, in *ModEntityMembershipRequest, opts ...grpc.CallOption) (*SimpleResult, error) {
	out := new(SimpleResult)
	err := grpc.Invoke(ctx, "/NetAuth/AddEntityToGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) RemoveEntityFromGroup(ctx context.Context, in *ModEntityMembershipRequest, opts ...grpc.CallOption) (*SimpleResult, error) {
	out := new(SimpleResult)
	err := grpc.Invoke(ctx, "/NetAuth/RemoveEntityFromGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netAuthClient) ModifyGroupNesting(ctx context.Context, in *ModGroupNestingRequest, opts ...grpc.CallOption) (*SimpleResult, error) {
	out := new(SimpleResult)
	err := grpc.Invoke(ctx, "/NetAuth/ModifyGroupNesting", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NetAuth service

type NetAuthServer interface {
	// It is desireable to ping the server for status and health
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	// AuthEntity and GetToken both verify that an entity is who they
	// claim to be (or at least that they posses the identifying
	// information) with the only difference being that GetToken will
	// unsurprisingly return a token on success.
	AuthEntity(context.Context, *NetAuthRequest) (*SimpleResult, error)
	GetToken(context.Context, *NetAuthRequest) (*TokenResult, error)
	ValidateToken(context.Context, *NetAuthRequest) (*SimpleResult, error)
	// ChangeSecret is unusual in that it uses the token if vouching for
	// *another* entity's secret being changed, but if the change is for
	// the requesting entity, the original secret must be provided.
	ChangeSecret(context.Context, *ModEntityRequest) (*SimpleResult, error)
	// AssignCapability assigns or removes capabilities on an entity or
	// a group.
	ManageCapabilities(context.Context, *ModCapabilityRequest) (*SimpleResult, error)
	// Add and remove Entities
	NewEntity(context.Context, *ModEntityRequest) (*SimpleResult, error)
	RemoveEntity(context.Context, *ModEntityRequest) (*SimpleResult, error)
	// Get and set meta information about entities
	EntityInfo(context.Context, *NetAuthRequest) (*Entity, error)
	ModifyEntityMeta(context.Context, *ModEntityRequest) (*SimpleResult, error)
	ModifyEntityKeys(context.Context, *ModEntityKeyRequest) (*KeyList, error)
	// Add, Remove, and Modify groups
	NewGroup(context.Context, *ModGroupRequest) (*SimpleResult, error)
	DeleteGroup(context.Context, *ModGroupRequest) (*SimpleResult, error)
	ModifyGroupMeta(context.Context, *ModGroupRequest) (*SimpleResult, error)
	GroupInfo(context.Context, *ModGroupRequest) (*GroupInfoResult, error)
	// List groups and members
	ListGroups(context.Context, *GroupListRequest) (*GroupList, error)
	ListGroupMembers(context.Context, *GroupMemberRequest) (*EntityList, error)
	// Modify direct group membership
	AddEntityToGroup(context.Context, *ModEntityMembershipRequest) (*SimpleResult, error)
	RemoveEntityFromGroup(context.Context, *ModEntityMembershipRequest) (*SimpleResult, error)
	// Modify nested group membership
	ModifyGroupNesting(context.Context, *ModGroupNestingRequest) (*SimpleResult, error)
}

func RegisterNetAuthServer(s *grpc.Server, srv NetAuthServer) {
	s.RegisterService(&_NetAuth_serviceDesc, srv)
}

func _NetAuth_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_AuthEntity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).AuthEntity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/AuthEntity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).AuthEntity(ctx, req.(*NetAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_GetToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).GetToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/GetToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).GetToken(ctx, req.(*NetAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_ValidateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).ValidateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/ValidateToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).ValidateToken(ctx, req.(*NetAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_ChangeSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModEntityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).ChangeSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/ChangeSecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).ChangeSecret(ctx, req.(*ModEntityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_ManageCapabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModCapabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).ManageCapabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/ManageCapabilities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).ManageCapabilities(ctx, req.(*ModCapabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_NewEntity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModEntityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).NewEntity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/NewEntity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).NewEntity(ctx, req.(*ModEntityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_RemoveEntity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModEntityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).RemoveEntity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/RemoveEntity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).RemoveEntity(ctx, req.(*ModEntityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_EntityInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).EntityInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/EntityInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).EntityInfo(ctx, req.(*NetAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_ModifyEntityMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModEntityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).ModifyEntityMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/ModifyEntityMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).ModifyEntityMeta(ctx, req.(*ModEntityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_ModifyEntityKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModEntityKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).ModifyEntityKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/ModifyEntityKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).ModifyEntityKeys(ctx, req.(*ModEntityKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_NewGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).NewGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/NewGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).NewGroup(ctx, req.(*ModGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_DeleteGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).DeleteGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/DeleteGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).DeleteGroup(ctx, req.(*ModGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_ModifyGroupMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).ModifyGroupMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/ModifyGroupMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).ModifyGroupMeta(ctx, req.(*ModGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_GroupInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).GroupInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/GroupInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).GroupInfo(ctx, req.(*ModGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_ListGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).ListGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/ListGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).ListGroups(ctx, req.(*GroupListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_ListGroupMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).ListGroupMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/ListGroupMembers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).ListGroupMembers(ctx, req.(*GroupMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_AddEntityToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModEntityMembershipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).AddEntityToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/AddEntityToGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).AddEntityToGroup(ctx, req.(*ModEntityMembershipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_RemoveEntityFromGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModEntityMembershipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).RemoveEntityFromGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/RemoveEntityFromGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).RemoveEntityFromGroup(ctx, req.(*ModEntityMembershipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetAuth_ModifyGroupNesting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModGroupNestingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetAuthServer).ModifyGroupNesting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetAuth/ModifyGroupNesting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetAuthServer).ModifyGroupNesting(ctx, req.(*ModGroupNestingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NetAuth_serviceDesc = grpc.ServiceDesc{
	ServiceName: "NetAuth",
	HandlerType: (*NetAuthServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _NetAuth_Ping_Handler,
		},
		{
			MethodName: "AuthEntity",
			Handler:    _NetAuth_AuthEntity_Handler,
		},
		{
			MethodName: "GetToken",
			Handler:    _NetAuth_GetToken_Handler,
		},
		{
			MethodName: "ValidateToken",
			Handler:    _NetAuth_ValidateToken_Handler,
		},
		{
			MethodName: "ChangeSecret",
			Handler:    _NetAuth_ChangeSecret_Handler,
		},
		{
			MethodName: "ManageCapabilities",
			Handler:    _NetAuth_ManageCapabilities_Handler,
		},
		{
			MethodName: "NewEntity",
			Handler:    _NetAuth_NewEntity_Handler,
		},
		{
			MethodName: "RemoveEntity",
			Handler:    _NetAuth_RemoveEntity_Handler,
		},
		{
			MethodName: "EntityInfo",
			Handler:    _NetAuth_EntityInfo_Handler,
		},
		{
			MethodName: "ModifyEntityMeta",
			Handler:    _NetAuth_ModifyEntityMeta_Handler,
		},
		{
			MethodName: "ModifyEntityKeys",
			Handler:    _NetAuth_ModifyEntityKeys_Handler,
		},
		{
			MethodName: "NewGroup",
			Handler:    _NetAuth_NewGroup_Handler,
		},
		{
			MethodName: "DeleteGroup",
			Handler:    _NetAuth_DeleteGroup_Handler,
		},
		{
			MethodName: "ModifyGroupMeta",
			Handler:    _NetAuth_ModifyGroupMeta_Handler,
		},
		{
			MethodName: "GroupInfo",
			Handler:    _NetAuth_GroupInfo_Handler,
		},
		{
			MethodName: "ListGroups",
			Handler:    _NetAuth_ListGroups_Handler,
		},
		{
			MethodName: "ListGroupMembers",
			Handler:    _NetAuth_ListGroupMembers_Handler,
		},
		{
			MethodName: "AddEntityToGroup",
			Handler:    _NetAuth_AddEntityToGroup_Handler,
		},
		{
			MethodName: "RemoveEntityFromGroup",
			Handler:    _NetAuth_RemoveEntityFromGroup_Handler,
		},
		{
			MethodName: "ModifyGroupNesting",
			Handler:    _NetAuth_ModifyGroupNesting_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "NetAuth.proto",
}

func init() { proto.RegisterFile("NetAuth.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1387 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xcb, 0x6e, 0xdb, 0x46,
	0x17, 0x36, 0x65, 0xc9, 0x92, 0x8e, 0x2e, 0xa6, 0x27, 0xb6, 0x43, 0x28, 0x37, 0xff, 0x04, 0x12,
	0x18, 0x09, 0x7e, 0x3a, 0x51, 0x82, 0x2c, 0x82, 0xa2, 0xa8, 0x2c, 0x31, 0x8a, 0x60, 0x4b, 0x32,
	0x28, 0x25, 0xa8, 0xbb, 0x31, 0x18, 0x69, 0x2c, 0x11, 0xa5, 0x48, 0x56, 0xa4, 0x92, 0xf2, 0x05,
	0xfa, 0x0e, 0xed, 0x1b, 0x74, 0xd5, 0x97, 0xe8, 0xb6, 0x9b, 0x02, 0x7d, 0x83, 0x3e, 0x45, 0xdb,
	0x45, 0x31, 0x17, 0x5e, 0x44, 0x4a, 0xb5, 0x92, 0x1d, 0xcf, 0x37, 0x73, 0x2e, 0xf3, 0xcd, 0x39,
	0x73, 0x0e, 0xa1, 0xd2, 0xc3, 0x5e, 0x63, 0xe1, 0x4d, 0x15, 0x67, 0x6e, 0x7b, 0xb6, 0xfc, 0x12,
	0xa0, 0x69, 0x1a, 0xd8, 0xf2, 0x3a, 0xd6, 0xb5, 0x8d, 0xaa, 0x90, 0xe9, 0xb4, 0x24, 0xe1, 0x48,
	0x38, 0x2e, 0x6a, 0x99, 0x4e, 0x0b, 0x49, 0x90, 0x1f, 0xe0, 0xf9, 0x07, 0x63, 0x84, 0xa5, 0x0c,
	0x05, 0x03, 0x51, 0x76, 0xa0, 0xca, 0x0d, 0x69, 0xf8, 0xbb, 0x05, 0x76, 0x3d, 0xf4, 0x00, 0x76,
	0x54, 0xcb, 0x33, 0x3c, 0x5f, 0x12, 0x8e, 0x32, 0xc7, 0xa5, 0x7a, 0x5e, 0x61, 0xa2, 0xc6, 0x61,
	0x74, 0x17, 0x8a, 0x64, 0xff, 0xd0, 0xfe, 0x16, 0x5b, 0xdc, 0x5c, 0x04, 0xa0, 0x07, 0x90, 0x25,
	0x21, 0x48, 0xdb, 0x47, 0xc2, 0x71, 0xa9, 0x5e, 0x52, 0xa2, 0xa8, 0x34, 0xba, 0x20, 0xff, 0x28,
	0x80, 0xd8, 0xb5, 0xc7, 0xdc, 0xe8, 0xa6, 0x4e, 0x1f, 0x42, 0x31, 0x54, 0xa2, 0x4e, 0x63, 0x7b,
	0xa2, 0x95, 0x1b, 0xbd, 0x2f, 0x07, 0x9f, 0x3d, 0xca, 0x2c, 0x05, 0x2f, 0xff, 0x22, 0xc0, 0xad,
	0xd0, 0xd8, 0x19, 0xf6, 0x3f, 0x97, 0x93, 0xcc, 0xa7, 0x71, 0x82, 0x10, 0x64, 0xbb, 0xf6, 0x18,
	0x4b, 0x59, 0xca, 0x26, 0xfd, 0x26, 0xd8, 0xd0, 0x77, 0xb0, 0x94, 0x63, 0x18, 0xf9, 0x46, 0x22,
	0x6c, 0x9f, 0x61, 0x5f, 0xda, 0xa1, 0x10, 0xf9, 0x94, 0x7f, 0x12, 0xa0, 0x16, 0x46, 0xdc, 0xc5,
	0xb3, 0xf7, 0x78, 0xee, 0x4e, 0x0d, 0x27, 0x16, 0x38, 0x5e, 0x1d, 0x38, 0x0e, 0x02, 0xcf, 0xb5,
	0xe7, 0xf6, 0xc2, 0x91, 0xb6, 0xe9, 0xfa, 0x8e, 0x42, 0x25, 0x8d, 0x81, 0x61, 0xe0, 0xd9, 0x8d,
	0xe8, 0xcc, 0x25, 0xe9, 0x34, 0x02, 0xda, 0x52, 0x09, 0x79, 0x08, 0x3b, 0xbd, 0x05, 0x09, 0x96,
	0xde, 0x65, 0x4e, 0xe3, 0x12, 0xc1, 0x5d, 0x3c, 0x9a, 0x63, 0x8f, 0x72, 0x55, 0xd4, 0xb8, 0x44,
	0x02, 0x99, 0x61, 0x4f, 0x0f, 0x03, 0x09, 0xce, 0xeb, 0xe9, 0x1a, 0x5d, 0x90, 0x1b, 0x50, 0x1e,
	0x18, 0x33, 0xc7, 0xc4, 0x1a, 0x76, 0x17, 0x26, 0x51, 0xc8, 0xbb, 0x8b, 0xd1, 0x08, 0xbb, 0x2e,
	0x3d, 0x79, 0xe1, 0x55, 0xee, 0x5a, 0x37, 0x5d, 0xac, 0x05, 0x28, 0xa1, 0x72, 0xe6, 0x4e, 0x78,
	0xfe, 0x92, 0x4f, 0xf9, 0x1d, 0x94, 0x68, 0xd8, 0x9f, 0x60, 0xa1, 0x1b, 0x59, 0xe8, 0xba, 0x13,
	0xb4, 0x0f, 0x39, 0xc6, 0x04, 0x0b, 0x9e, 0x09, 0xf2, 0x3d, 0xc8, 0x9f, 0x61, 0xff, 0xdc, 0x70,
	0x3d, 0x72, 0xa7, 0x67, 0xd8, 0x27, 0x06, 0xb7, 0xc9, 0x9d, 0x92, 0x6f, 0xf9, 0x57, 0x81, 0x5f,
	0x01, 0x59, 0xed, 0xe9, 0x33, 0xcc, 0x69, 0xa2, 0xdf, 0xe8, 0x08, 0x4a, 0x2d, 0xc3, 0x75, 0x4c,
	0xdd, 0xa7, 0x4b, 0xcc, 0x59, 0x1c, 0x8a, 0x51, 0xb9, 0xbd, 0x44, 0xe5, 0x5d, 0x28, 0x76, 0x75,
	0x4b, 0x9f, 0xe0, 0xf1, 0xa9, 0xcf, 0x93, 0x28, 0x02, 0xd0, 0x09, 0x94, 0x9b, 0xba, 0xa3, 0xbf,
	0x37, 0x4c, 0xc3, 0x33, 0xb0, 0x2b, 0xd5, 0x8f, 0xb6, 0x8f, 0xab, 0xe4, 0x86, 0x03, 0xd0, 0xd7,
	0x96, 0x36, 0xa0, 0xfb, 0x00, 0xea, 0xf7, 0x8e, 0x6e, 0xb9, 0x86, 0x6d, 0xb9, 0xd2, 0x73, 0x7a,
	0x80, 0x18, 0x22, 0x5b, 0xb0, 0xdb, 0xb5, 0xc7, 0x2c, 0x7b, 0x78, 0xf2, 0x2d, 0x25, 0x87, 0x90,
	0x2c, 0x8a, 0x30, 0xf3, 0x32, 0xff, 0x95, 0x79, 0x6b, 0x9f, 0x91, 0x01, 0x20, 0xba, 0x93, 0xe5,
	0x7c, 0xe4, 0x92, 0x1b, 0x15, 0xa8, 0xde, 0x1a, 0xa3, 0x99, 0x75, 0x46, 0x7f, 0x10, 0x40, 0xa4,
	0x5b, 0xc9, 0x6d, 0x45, 0x35, 0xc4, 0xb4, 0x84, 0x75, 0x45, 0x10, 0xbd, 0x0e, 0x89, 0x87, 0x29,
	0xc8, 0xfe, 0xa7, 0x20, 0x76, 0xac, 0x91, 0xb9, 0x18, 0xe3, 0x8e, 0x35, 0x36, 0xe6, 0x78, 0xe4,
	0xb9, 0xf4, 0x60, 0x85, 0x57, 0x59, 0x6f, 0xbe, 0xc0, 0x5a, 0x6a, 0x55, 0x7e, 0x02, 0xc5, 0x30,
	0x0e, 0x74, 0x1f, 0x76, 0xa8, 0xc0, 0xf2, 0x26, 0x3a, 0x15, 0x47, 0xe5, 0x0e, 0xec, 0xd2, 0x2f,
	0x1a, 0x12, 0x4b, 0xde, 0x18, 0x0f, 0x2b, 0xc8, 0x95, 0x20, 0xcf, 0x33, 0x41, 0xca, 0xd0, 0x8b,
	0x0c, 0x44, 0xf9, 0xf7, 0x0c, 0x40, 0x54, 0x5b, 0xa8, 0x06, 0x59, 0x67, 0x62, 0x8c, 0x13, 0x6c,
	0x52, 0x8c, 0x24, 0x7b, 0x5b, 0x6d, 0xf6, 0x07, 0x3c, 0x27, 0x99, 0x40, 0xee, 0xfc, 0x1c, 0x4f,
	0x74, 0x93, 0x66, 0x2b, 0x2b, 0x83, 0x08, 0x48, 0x66, 0x73, 0x36, 0x9d, 0xcd, 0x08, 0xb2, 0x6f,
	0xec, 0x59, 0xf8, 0xea, 0x91, 0x6f, 0xe2, 0x69, 0x30, 0xc5, 0xa6, 0xc9, 0xdf, 0x3d, 0x26, 0xa0,
	0x47, 0x50, 0x6d, 0xcf, 0x75, 0x67, 0x6a, 0x8c, 0x74, 0x93, 0x2d, 0xe7, 0xe9, 0x72, 0x02, 0x25,
	0x3e, 0x4f, 0xf5, 0xf1, 0x04, 0xf3, 0x22, 0x29, 0x30, 0x9f, 0x31, 0x08, 0xdd, 0x0e, 0xf9, 0xfd,
	0x8b, 0x15, 0x26, 0x17, 0xd1, 0xd3, 0x44, 0x91, 0xfc, 0x2d, 0xdc, 0x54, 0x25, 0xb7, 0x78, 0x81,
	0xff, 0x13, 0xaf, 0xf0, 0x93, 0x80, 0x53, 0x7a, 0x9b, 0xff, 0x83, 0x3c, 0x7f, 0xa7, 0xf9, 0x75,
	0x86, 0xe9, 0x12, 0xe0, 0xf2, 0x6f, 0x02, 0x1c, 0x06, 0xc5, 0xd4, 0xc3, 0xae, 0x67, 0x58, 0x93,
	0xcd, 0x6a, 0xea, 0x18, 0x4a, 0x17, 0xfa, 0x1c, 0x5b, 0xde, 0xaa, 0xca, 0x8a, 0x2f, 0xa1, 0x47,
	0x00, 0xcd, 0xa9, 0x61, 0x8e, 0x57, 0x3d, 0xfe, 0xb1, 0x15, 0x24, 0xc7, 0x3a, 0x53, 0xb5, 0x5e,
	0x55, 0xc2, 0x8a, 0x27, 0x28, 0xef, 0x54, 0x41, 0x81, 0xe4, 0xd6, 0x95, 0xd5, 0x1f, 0x02, 0xec,
	0x77, 0xed, 0x71, 0x8c, 0xb5, 0x8d, 0x4e, 0x73, 0x63, 0x5d, 0xc5, 0x9a, 0xd7, 0x8a, 0x6a, 0x8f,
	0x9a, 0x6a, 0x26, 0x6c, 0xaa, 0x4f, 0x00, 0xa2, 0x28, 0x68, 0xc3, 0x4a, 0x5c, 0x67, 0x6c, 0x39,
	0x3c, 0xd7, 0xce, 0xba, 0x73, 0x29, 0x50, 0xba, 0x88, 0xdd, 0xcd, 0x4d, 0x0f, 0x85, 0xfc, 0x0a,
	0xca, 0x6c, 0xbf, 0xeb, 0xd8, 0x96, 0x8b, 0x49, 0x1d, 0xbe, 0xc1, 0xba, 0xe9, 0x4d, 0x7d, 0xaa,
	0x53, 0xd0, 0x02, 0x31, 0xdd, 0x5b, 0x1e, 0xff, 0x29, 0xc4, 0x43, 0x47, 0xbb, 0x50, 0x6a, 0x9f,
	0xf7, 0x4f, 0x1b, 0xe7, 0x57, 0x5a, 0xbf, 0x3f, 0x14, 0xb7, 0xd0, 0x1e, 0x54, 0x9a, 0x9a, 0xda,
	0x18, 0xaa, 0x57, 0x6a, 0x6f, 0xd8, 0x19, 0x5e, 0x8a, 0x80, 0x10, 0x54, 0x5b, 0xea, 0x60, 0xd8,
	0xd7, 0x2e, 0x03, 0xac, 0x84, 0x0e, 0x01, 0x75, 0xfb, 0xad, 0xce, 0xeb, 0x00, 0xba, 0xea, 0xaa,
	0xc3, 0x86, 0x58, 0x4e, 0xe3, 0x67, 0xea, 0xe5, 0x40, 0xac, 0x20, 0x09, 0xf6, 0x9b, 0x6f, 0x1a,
	0xbd, 0x76, 0x60, 0xf6, 0x6a, 0xa0, 0x36, 0x35, 0x75, 0x28, 0x56, 0x91, 0x08, 0x65, 0xee, 0xb0,
	0xad, 0xf5, 0xdf, 0x5e, 0x88, 0xfb, 0x24, 0x04, 0xe2, 0x4f, 0xeb, 0x5f, 0x72, 0xe8, 0x00, 0x1d,
	0xc0, 0x1e, 0x37, 0x4b, 0x11, 0xe6, 0xed, 0x90, 0x58, 0x4d, 0xc0, 0xdd, 0x53, 0x55, 0x1b, 0x88,
	0xb7, 0x1f, 0x3f, 0x87, 0xca, 0x52, 0x8a, 0xa1, 0x12, 0xe4, 0x3b, 0xbd, 0xe6, 0xf9, 0xdb, 0x96,
	0x2a, 0x0a, 0x44, 0x50, 0xbf, 0x66, 0x42, 0x06, 0x15, 0x20, 0xdb, 0xd2, 0xfa, 0x17, 0xe2, 0xa8,
	0xfe, 0x73, 0x01, 0xf2, 0x7c, 0x8a, 0x45, 0x0f, 0x21, 0x4b, 0x38, 0x46, 0x65, 0x25, 0x76, 0x35,
	0xb5, 0x8a, 0x12, 0x27, 0x5e, 0xde, 0x42, 0x0a, 0x00, 0xd9, 0xce, 0x13, 0x69, 0x57, 0x59, 0x1e,
	0x82, 0x6b, 0x15, 0x25, 0x3e, 0x4d, 0xc8, 0x5b, 0xe8, 0x09, 0x14, 0xda, 0xd8, 0x63, 0x79, 0x99,
	0xda, 0x5d, 0x56, 0x62, 0x83, 0x83, 0xbc, 0x85, 0x9e, 0x41, 0xe5, 0x9d, 0x6e, 0x1a, 0x63, 0xdd,
	0xc3, 0x6b, 0x34, 0x52, 0xf6, 0xeb, 0x50, 0x6e, 0x4e, 0x75, 0x6b, 0x82, 0x07, 0x6c, 0xe0, 0xd9,
	0x53, 0x92, 0x33, 0x72, 0x5a, 0xe7, 0x0b, 0x40, 0xec, 0xdd, 0x5e, 0x7a, 0x82, 0x0e, 0x94, 0x55,
	0xa5, 0x96, 0xd6, 0x3e, 0x81, 0x62, 0x0f, 0x7f, 0xe4, 0x04, 0x6c, 0xe2, 0xae, 0x0e, 0x65, 0x0d,
	0xcf, 0xec, 0x0f, 0xf8, 0x13, 0x74, 0x8e, 0x83, 0xa7, 0x8f, 0x36, 0xca, 0x14, 0x0d, 0x41, 0x45,
	0xcb, 0x5b, 0xe8, 0x25, 0xfd, 0x2b, 0x30, 0xae, 0xfd, 0x58, 0xfb, 0xd9, 0xc4, 0xc3, 0x8b, 0x65,
	0x3d, 0xf2, 0xe0, 0xa2, 0x7d, 0x65, 0xc5, 0x10, 0x5f, 0x2b, 0x28, 0x7c, 0x0c, 0x93, 0xb7, 0xd0,
	0xff, 0xa1, 0xd0, 0xc3, 0x1f, 0xd9, 0x3b, 0x21, 0x2a, 0x89, 0xc1, 0x25, 0xed, 0xe4, 0x29, 0x94,
	0x5a, 0xd8, 0xc4, 0x1e, 0xde, 0x58, 0xe3, 0x05, 0x1d, 0x87, 0x8c, 0x6b, 0x9f, 0x0f, 0x29, 0x9e,
	0xbe, 0x89, 0xd6, 0x33, 0xde, 0xf6, 0x29, 0x5b, 0xe9, 0xfd, 0xa2, 0x92, 0xe8, 0xf3, 0xf4, 0x24,
	0x40, 0xce, 0xc4, 0x3b, 0xd6, 0x9e, 0x92, 0x1c, 0x5f, 0x6a, 0x10, 0x41, 0x8c, 0xe6, 0x70, 0x3b,
	0x6f, 0x37, 0xe8, 0x96, 0x92, 0x9e, 0xa4, 0x6a, 0xc1, 0x8c, 0xcd, 0xf5, 0xbe, 0x02, 0xb1, 0x31,
	0xe6, 0x9c, 0x0e, 0x6d, 0x46, 0xc3, 0x1d, 0x65, 0xfd, 0x9f, 0x47, 0xfa, 0x6c, 0x2a, 0x1c, 0xc4,
	0xd3, 0xe7, 0xf5, 0xdc, 0x9e, 0x7d, 0x8e, 0x99, 0x2f, 0x01, 0xc5, 0x88, 0xe5, 0xdd, 0x11, 0xdd,
	0x56, 0x56, 0xf7, 0xcb, 0x94, 0xfe, 0xe9, 0xbd, 0x6f, 0xee, 0x4c, 0x0c, 0x6f, 0xba, 0x78, 0xaf,
	0x8c, 0xec, 0xd9, 0x09, 0xcf, 0xc7, 0x93, 0x0b, 0xf2, 0x13, 0x3d, 0xb2, 0xcd, 0x7f, 0x03, 0x00,
	0x00, 0xff, 0xff, 0x50, 0x23, 0xbe, 0xe6, 0x57, 0x0f, 0x00, 0x00,
}
