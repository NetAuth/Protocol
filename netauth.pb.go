// Code generated by protoc-gen-go. DO NOT EDIT.
// source: netauth.proto

/*
Package protocol is a generated protocol buffer package.

It is generated from these files:
	netauth.proto

It has these top-level messages:
	KVData
	KVValue
	Entity
	EntityMeta
	Group
*/
package protocol

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Capabilities permit the holder to perform special actions within
// NetAuth.  This allows the holder to do things related to management
// of the server without needing to use the GLOBAL_ROOT bootstrap
// user.
type Capability int32

const (
	Capability_GLOBAL_ROOT          Capability = 0
	Capability_CREATE_ENTITY        Capability = 10
	Capability_DESTROY_ENTITY       Capability = 11
	Capability_MODIFY_ENTITY_META   Capability = 12
	Capability_MODIFY_ENTITY_KEYS   Capability = 13
	Capability_CHANGE_ENTITY_SECRET Capability = 14
	Capability_LOCK_ENTITY          Capability = 15
	Capability_UNLOCK_ENTITY        Capability = 16
	Capability_CREATE_GROUP         Capability = 20
	Capability_DESTROY_GROUP        Capability = 21
	Capability_MODIFY_GROUP_META    Capability = 22
	Capability_MODIFY_GROUP_MEMBERS Capability = 23
)

var Capability_name = map[int32]string{
	0:  "GLOBAL_ROOT",
	10: "CREATE_ENTITY",
	11: "DESTROY_ENTITY",
	12: "MODIFY_ENTITY_META",
	13: "MODIFY_ENTITY_KEYS",
	14: "CHANGE_ENTITY_SECRET",
	15: "LOCK_ENTITY",
	16: "UNLOCK_ENTITY",
	20: "CREATE_GROUP",
	21: "DESTROY_GROUP",
	22: "MODIFY_GROUP_META",
	23: "MODIFY_GROUP_MEMBERS",
}
var Capability_value = map[string]int32{
	"GLOBAL_ROOT":          0,
	"CREATE_ENTITY":        10,
	"DESTROY_ENTITY":       11,
	"MODIFY_ENTITY_META":   12,
	"MODIFY_ENTITY_KEYS":   13,
	"CHANGE_ENTITY_SECRET": 14,
	"LOCK_ENTITY":          15,
	"UNLOCK_ENTITY":        16,
	"CREATE_GROUP":         20,
	"DESTROY_GROUP":        21,
	"MODIFY_GROUP_META":    22,
	"MODIFY_GROUP_MEMBERS": 23,
}

func (x Capability) Enum() *Capability {
	p := new(Capability)
	*p = x
	return p
}
func (x Capability) String() string {
	return proto.EnumName(Capability_name, int32(x))
}
func (x *Capability) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Capability_value, data, "Capability")
	if err != nil {
		return err
	}
	*x = Capability(value)
	return nil
}
func (Capability) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Group expansions can either be to include children of the named
// group, or to exclude them.
type ExpansionMode int32

const (
	ExpansionMode_INCLUDE ExpansionMode = 1
	ExpansionMode_EXCLUDE ExpansionMode = 2
	ExpansionMode_DROP    ExpansionMode = 99
)

var ExpansionMode_name = map[int32]string{
	1:  "INCLUDE",
	2:  "EXCLUDE",
	99: "DROP",
}
var ExpansionMode_value = map[string]int32{
	"INCLUDE": 1,
	"EXCLUDE": 2,
	"DROP":    99,
}

func (x ExpansionMode) Enum() *ExpansionMode {
	p := new(ExpansionMode)
	*p = x
	return p
}
func (x ExpansionMode) String() string {
	return proto.EnumName(ExpansionMode_name, int32(x))
}
func (x *ExpansionMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ExpansionMode_value, data, "ExpansionMode")
	if err != nil {
		return err
	}
	*x = ExpansionMode(value)
	return nil
}
func (ExpansionMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// KVData holds the data for a single Key/Value dataset.  It is based
// on holding the key which may be multi-valued, and may be an arbitrary
// string.
type KVData struct {
	// A key needs to be representable as a string, though it is not //
	// used for anything internally beyond a byte comparision for equality.
	Key *string `protobuf:"bytes,1,req,name=Key" json:"Key,omitempty"`
	// A key may have one or more values.  The values are completely
	// opaque to NetAuth, but must be storeable as strings and have an
	// implementation defined length.  By default they are not to exceed
	// 64M.
	Values           []*KVValue `protobuf:"bytes,2,rep,name=Values" json:"Values,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *KVData) Reset()                    { *m = KVData{} }
func (m *KVData) String() string            { return proto.CompactTextString(m) }
func (*KVData) ProtoMessage()               {}
func (*KVData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *KVData) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *KVData) GetValues() []*KVValue {
	if m != nil {
		return m.Values
	}
	return nil
}

// KVValue contains the actual values in the key/value system.  The
// values are arbitrary strings, which carry with them an optional
// ordering index.  Ordering indexes are not guaranteed to be unique.
type KVValue struct {
	Value            *string `protobuf:"bytes,1,req,name=Value" json:"Value,omitempty"`
	Index            *int32  `protobuf:"varint,2,opt,name=Index" json:"Index,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *KVValue) Reset()                    { *m = KVValue{} }
func (m *KVValue) String() string            { return proto.CompactTextString(m) }
func (*KVValue) ProtoMessage()               {}
func (*KVValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *KVValue) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *KVValue) GetIndex() int32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

// An entity may be a person or a machine actor that wishes to act as
// some identity.  To do so they will need to transmit an ID and a
// secret which will be used to verify that they are who they say they
// are.
type Entity struct {
	// The entity may be identified by a string.  This is most common
	// for the initial authentication case where a people-entity has
	// typed a name in and now wishes to be authenticated.
	ID *string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	// An entity might also be identified by a unique ID number.  This
	// case is most common when some program wishes to get information
	// about an entity.
	Number *int32 `protobuf:"varint,2,opt,name=Number" json:"Number,omitempty"`
	// The entity may have a secret which they will use to authenticate
	// themselves.
	Secret *string `protobuf:"bytes,3,opt,name=secret" json:"secret,omitempty"`
	// For requests that update the meta information this must be
	// attatched to the entity itself.  This also allows the in-memory
	// format to be defined by this proto.
	Meta             *EntityMeta `protobuf:"bytes,4,opt,name=meta" json:"meta,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Entity) Reset()                    { *m = Entity{} }
func (m *Entity) String() string            { return proto.CompactTextString(m) }
func (*Entity) ProtoMessage()               {}
func (*Entity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Entity) GetID() string {
	if m != nil && m.ID != nil {
		return *m.ID
	}
	return ""
}

func (m *Entity) GetNumber() int32 {
	if m != nil && m.Number != nil {
		return *m.Number
	}
	return 0
}

func (m *Entity) GetSecret() string {
	if m != nil && m.Secret != nil {
		return *m.Secret
	}
	return ""
}

func (m *Entity) GetMeta() *EntityMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

// The EntityMeta structure contains additional information about the
// entity in question.  This is the "directory" part of NetAuth's
// ecosystem and contains information you might want to know about an
// entity.
type EntityMeta struct {
	// The primary group ID for the entity.  On most UNIX systems this
	// will map to a group with the same string representation as the
	// Entity, but it is not uncommon for people-entities in a network
	// environment to not have a personal primary group and instead
	// belong to an organization wide primary group.
	PrimaryGroup *string `protobuf:"bytes,1,opt,name=PrimaryGroup" json:"PrimaryGroup,omitempty"`
	// This is an arbitrary field used to store things like the user's
	// real name.  It is here for consistency, but the name displayed by
	// the user should really be stored in displayName, with the actual
	// name stored in legalName (this facilitates a user to have an
	// arbitrary name displayed if this is permitted by local policy).
	GECOS *string `protobuf:"bytes,2,opt,name=GECOS" json:"GECOS,omitempty"`
	// This stores the legal name (if used) that owns this security
	// entity.  This primarily here for places where knowing the single
	// owning entity is a requirement for compliance reasons.
	LegalName *string `protobuf:"bytes,3,opt,name=LegalName" json:"LegalName,omitempty"`
	// This field is for the display value of the legalName.  This lets
	// the displayed value fluctuate with no connection to the actual
	// identity of the owning entity.
	DisplayName *string `protobuf:"bytes,4,opt,name=DisplayName" json:"DisplayName,omitempty"`
	// Given that the entity identity and auth are provided by the
	// network, its not unlikely that the home directory for the entity
	// is as well.  This string contains the fully qualified path to the
	// home directory.
	Home *string `protobuf:"bytes,5,opt,name=Home" json:"Home,omitempty"`
	// This string is the canonical 'user command interpreter' specified
	// in the passwd file.  This value provided by this field must be
	// safe to use on all target systems as setting this to something
	// that doesn't exist on the targets will cause the login program to
	// abort when setting up the environment.
	Shell *string `protobuf:"bytes,6,opt,name=Shell" json:"Shell,omitempty"`
	// This is for the graphical shell, primarily for when the entity is
	// a person (though machine entities might also need to have a
	// graphical shell set).  This provides a handy place to store it,
	// but unfortunately a seperate mechanism is needed to get this into
	// the systems that actually setup the graphical environment.
	GraphicalShell *string `protobuf:"bytes,7,opt,name=GraphicalShell" json:"GraphicalShell,omitempty"`
	// Person entities may have a physical badge which gets them access
	// to things, and machine entities may have an asset tag which is
	// nice to keep track of.  This is a string rather than a number
	// because the badge "number" might actually be a UUID or something
	// that is not otherwise a pure number.
	BadgeNumber *string `protobuf:"bytes,8,opt,name=BadgeNumber" json:"BadgeNumber,omitempty"`
	// An entity can be locked such that they cannot authenticate at
	// all.  This instructs the server to refuse authentication attempts
	// before considering the secret (if provided).
	Locked *bool `protobuf:"varint,9,opt,name=Locked" json:"Locked,omitempty"`
	// Entities may be direct members of groups
	Groups []string `protobuf:"bytes,250,rep,name=Groups" json:"Groups,omitempty"`
	// Entities may have capabilities that provide special actions to
	// the holder within NetAuth.
	Capabilities []Capability `protobuf:"varint,251,rep,name=Capabilities,enum=Capability" json:"Capabilities,omitempty"`
	// Entities may also have one or more Keys associated with them.
	// This is deliberately untyped to allow it to be TYPE:KEY rather
	// than needing a protocol update every time a new type of key
	// should be stored.
	Keys []string `protobuf:"bytes,252,rep,name=Keys" json:"Keys,omitempty"`
	// While NetAuth isn't a general purpose directory, it will
	// undoubtedly be abused in that way.  To make this somewhat more
	// palatable, a generic K/V field is included.
	UntypedMeta []string `protobuf:"bytes,253,rep,name=UntypedMeta" json:"UntypedMeta,omitempty"`
	// The earlier UntypedMeta implementation had many problems.  It has
	// been superceded by the KVData approach which permits quick sorting
	// of values without manipulating strings, keys that have no reserved
	// characters, and a generally cleaner interface.
	KV               []*KVData `protobuf:"bytes,254,rep,name=KV" json:"KV,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *EntityMeta) Reset()                    { *m = EntityMeta{} }
func (m *EntityMeta) String() string            { return proto.CompactTextString(m) }
func (*EntityMeta) ProtoMessage()               {}
func (*EntityMeta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *EntityMeta) GetPrimaryGroup() string {
	if m != nil && m.PrimaryGroup != nil {
		return *m.PrimaryGroup
	}
	return ""
}

func (m *EntityMeta) GetGECOS() string {
	if m != nil && m.GECOS != nil {
		return *m.GECOS
	}
	return ""
}

func (m *EntityMeta) GetLegalName() string {
	if m != nil && m.LegalName != nil {
		return *m.LegalName
	}
	return ""
}

func (m *EntityMeta) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *EntityMeta) GetHome() string {
	if m != nil && m.Home != nil {
		return *m.Home
	}
	return ""
}

func (m *EntityMeta) GetShell() string {
	if m != nil && m.Shell != nil {
		return *m.Shell
	}
	return ""
}

func (m *EntityMeta) GetGraphicalShell() string {
	if m != nil && m.GraphicalShell != nil {
		return *m.GraphicalShell
	}
	return ""
}

func (m *EntityMeta) GetBadgeNumber() string {
	if m != nil && m.BadgeNumber != nil {
		return *m.BadgeNumber
	}
	return ""
}

func (m *EntityMeta) GetLocked() bool {
	if m != nil && m.Locked != nil {
		return *m.Locked
	}
	return false
}

func (m *EntityMeta) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *EntityMeta) GetCapabilities() []Capability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

func (m *EntityMeta) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *EntityMeta) GetUntypedMeta() []string {
	if m != nil {
		return m.UntypedMeta
	}
	return nil
}

func (m *EntityMeta) GetKV() []*KVData {
	if m != nil {
		return m.KV
	}
	return nil
}

// While machine entities may belong to only one group, people
// entities often belong to many groups at once.  This message
// structures the reply for the additional groups.
type Group struct {
	// A group name must satisfy the requirements of the UNIX group
	// naming conventions.  This should be one word, lower case, with no
	// spaces and cannot begin with a number.
	Name *string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	// Since the name has strict naming requirements, its nice to have a
	// displayName for the group which has a more friendly display.
	// Instead of trying to reason out what naacct means, its much nicer
	// to just know that its "Accounting team - North America"
	DisplayName *string `protobuf:"bytes,2,opt,name=DisplayName" json:"DisplayName,omitempty"`
	// On *nix systems the group should also have a number.  This number
	// should be the same across all systems since it may be used for
	// internal matching of users.
	Number *int32 `protobuf:"varint,3,opt,name=Number" json:"Number,omitempty"`
	// Groups can be managed by other groups.  For a group to be self
	// managed, one would set the managed by group to be the group
	// itself.
	ManagedBy *string `protobuf:"bytes,5,opt,name=ManagedBy" json:"ManagedBy,omitempty"`
	// Groups may have capabilities that are conferred to members of the
	// group on a membership basis.  This is the preferred way of
	// granting capabilities to an entity since it means that when an
	// entity is removed from the group they lose the capabilities that
	// were granted from it.
	Capabilities []Capability `protobuf:"varint,50,rep,name=Capabilities,enum=Capability" json:"Capabilities,omitempty"`
	// Groups can also be members of other groups.  This allows a group
	// to appear to contain a larger membership and build this
	// membership based on potentially very intricate include/exclude
	// rules.  The format of this field is "<mode>:<group>" so if you
	// were including the membership of 'foo', then it would have the
	// value of "INCLUDE:foo".
	Expansions []string `protobuf:"bytes,51,rep,name=Expansions" json:"Expansions,omitempty"`
	// While NetAuth isn't a general purpose directory, it will
	// undoubtedly be abused in that way.  To make this somewhat more
	// palatable, a generic K/V field is included.
	UntypedMeta []string `protobuf:"bytes,100,rep,name=UntypedMeta" json:"UntypedMeta,omitempty"`
	// The earlier UntypedMeta implementation had many problems.  It has
	// been superceded by the KVData approach which permits quick sorting
	// of values without manipulating strings, keys that have no reserved
	// characters, and a generally cleaner interface.
	KV               []*KVData `protobuf:"bytes,254,rep,name=KV" json:"KV,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Group) Reset()                    { *m = Group{} }
func (m *Group) String() string            { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()               {}
func (*Group) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Group) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Group) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *Group) GetNumber() int32 {
	if m != nil && m.Number != nil {
		return *m.Number
	}
	return 0
}

func (m *Group) GetManagedBy() string {
	if m != nil && m.ManagedBy != nil {
		return *m.ManagedBy
	}
	return ""
}

func (m *Group) GetCapabilities() []Capability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

func (m *Group) GetExpansions() []string {
	if m != nil {
		return m.Expansions
	}
	return nil
}

func (m *Group) GetUntypedMeta() []string {
	if m != nil {
		return m.UntypedMeta
	}
	return nil
}

func (m *Group) GetKV() []*KVData {
	if m != nil {
		return m.KV
	}
	return nil
}

func init() {
	proto.RegisterType((*KVData)(nil), "KVData")
	proto.RegisterType((*KVValue)(nil), "KVValue")
	proto.RegisterType((*Entity)(nil), "Entity")
	proto.RegisterType((*EntityMeta)(nil), "EntityMeta")
	proto.RegisterType((*Group)(nil), "Group")
	proto.RegisterEnum("Capability", Capability_name, Capability_value)
	proto.RegisterEnum("ExpansionMode", ExpansionMode_name, ExpansionMode_value)
}

func init() { proto.RegisterFile("netauth.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 685 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x94, 0x4b, 0x6f, 0xda, 0x4e,
	0x14, 0xc5, 0xff, 0x36, 0xe6, 0x75, 0x0d, 0xc4, 0xb9, 0xff, 0x3c, 0x46, 0x6a, 0xda, 0xba, 0x2c,
	0x2a, 0x94, 0x05, 0xa9, 0x88, 0xba, 0xeb, 0x06, 0xb0, 0x4b, 0x90, 0x01, 0x47, 0xc3, 0x43, 0x4d,
	0x37, 0x68, 0x02, 0x23, 0xb0, 0x6a, 0x30, 0xc2, 0x46, 0x8a, 0x77, 0x5d, 0xf6, 0xdb, 0xf4, 0xfb,
	0xf5, 0xa5, 0xca, 0x63, 0x13, 0x48, 0x52, 0xa9, 0xea, 0x6e, 0xce, 0xef, 0x8e, 0xef, 0x3d, 0x73,
	0x66, 0x64, 0x28, 0x2e, 0x79, 0xc0, 0x36, 0xc1, 0xbc, 0xba, 0x5a, 0x7b, 0x81, 0x57, 0x7e, 0x07,
	0x19, 0x6b, 0x64, 0xb0, 0x80, 0xa1, 0x06, 0x29, 0x8b, 0x87, 0x44, 0xd2, 0xe5, 0x4a, 0x9e, 0x46,
	0x4b, 0xd4, 0x21, 0x33, 0x62, 0xee, 0x86, 0xfb, 0x44, 0xd6, 0x53, 0x15, 0xb5, 0x96, 0xab, 0x5a,
	0x23, 0x01, 0x68, 0xc2, 0xcb, 0x6f, 0x21, 0x9b, 0x20, 0x3c, 0x82, 0xb4, 0x58, 0x24, 0x0d, 0xd2,
	0xf7, 0xb4, 0xbd, 0x9c, 0xf2, 0x3b, 0x22, 0xeb, 0x52, 0x25, 0x4d, 0x63, 0x51, 0x76, 0x20, 0x63,
	0x2e, 0x03, 0x27, 0x08, 0xb1, 0x04, 0x72, 0xdb, 0x20, 0x92, 0x2e, 0x55, 0xf2, 0x54, 0x6e, 0x1b,
	0x78, 0x02, 0x99, 0xde, 0x66, 0x71, 0xcb, 0xd7, 0xc9, 0x07, 0x89, 0x8a, 0xb8, 0xcf, 0x27, 0x6b,
	0x1e, 0x90, 0x94, 0xd8, 0x9b, 0x28, 0x7c, 0x09, 0xca, 0x82, 0x07, 0x8c, 0x28, 0xba, 0x54, 0x51,
	0x6b, 0x6a, 0x35, 0x6e, 0xdb, 0xe5, 0x01, 0xa3, 0xa2, 0x50, 0xfe, 0x9a, 0x02, 0xd8, 0x41, 0x2c,
	0x43, 0xe1, 0x7a, 0xed, 0x2c, 0xd8, 0x3a, 0x6c, 0xad, 0xbd, 0xcd, 0x2a, 0x99, 0xfc, 0x80, 0x45,
	0x9e, 0x5b, 0x66, 0xd3, 0xee, 0x0b, 0x0b, 0x79, 0x1a, 0x0b, 0x3c, 0x83, 0x7c, 0x87, 0xcf, 0x98,
	0xdb, 0x63, 0x0b, 0x9e, 0x98, 0xd8, 0x01, 0xd4, 0x41, 0x35, 0x1c, 0x7f, 0xe5, 0xb2, 0x50, 0xd4,
	0x15, 0x51, 0xdf, 0x47, 0x88, 0xa0, 0x5c, 0x79, 0x0b, 0x4e, 0xd2, 0xa2, 0x24, 0xd6, 0xd1, 0xa4,
	0xfe, 0x9c, 0xbb, 0x2e, 0xc9, 0xc4, 0x93, 0x84, 0xc0, 0xd7, 0x50, 0x6a, 0xad, 0xd9, 0x6a, 0xee,
	0x4c, 0x98, 0x1b, 0x97, 0xb3, 0xa2, 0xfc, 0x88, 0x46, 0x33, 0x1b, 0x6c, 0x3a, 0xe3, 0x49, 0x60,
	0xb9, 0x78, 0xe6, 0x1e, 0x8a, 0x52, 0xeb, 0x78, 0x93, 0x4f, 0x7c, 0x4a, 0xf2, 0xba, 0x54, 0xc9,
	0xd1, 0x44, 0xe1, 0x29, 0x64, 0xc4, 0x51, 0x7d, 0xf2, 0x4d, 0xd2, 0x53, 0x51, 0x9c, 0xb1, 0xc4,
	0x37, 0x50, 0x68, 0xb2, 0x15, 0xbb, 0x75, 0x5c, 0x27, 0x70, 0xb8, 0x4f, 0xbe, 0x47, 0xe5, 0x52,
	0x4d, 0xad, 0xde, 0xd3, 0x90, 0x3e, 0xd8, 0x81, 0xff, 0x83, 0x62, 0xf1, 0xd0, 0x27, 0x3f, 0xe2,
	0x46, 0x42, 0xe0, 0x2b, 0x50, 0x87, 0xcb, 0x20, 0x5c, 0xf1, 0x69, 0x14, 0x3a, 0xf9, 0x19, 0xd7,
	0xf6, 0x19, 0x12, 0x90, 0xad, 0x11, 0xf9, 0x25, 0x89, 0x87, 0x95, 0xad, 0xc6, 0x6f, 0x90, 0xca,
	0xd6, 0xa8, 0xfc, 0x59, 0x86, 0x74, 0x7c, 0x11, 0x08, 0x8a, 0x48, 0x33, 0xbe, 0x24, 0xe5, 0x4f,
	0x41, 0xcb, 0x4f, 0x83, 0xde, 0x3d, 0xa1, 0xd4, 0x83, 0x27, 0x74, 0x06, 0xf9, 0x2e, 0x5b, 0xb2,
	0x19, 0x9f, 0x36, 0xc2, 0xe4, 0x16, 0x76, 0x00, 0x2f, 0x1e, 0x9d, 0xbc, 0xf6, 0xb7, 0x83, 0xbf,
	0x00, 0x30, 0xef, 0x56, 0x6c, 0xe9, 0x3b, 0xde, 0xd2, 0x27, 0x97, 0xe2, 0x84, 0x7b, 0x24, 0x32,
	0xba, 0x9f, 0xc1, 0xf4, 0x1f, 0x22, 0x38, 0xff, 0x22, 0x03, 0xec, 0x06, 0xe3, 0x01, 0xa8, 0xad,
	0x8e, 0xdd, 0xa8, 0x77, 0xc6, 0xd4, 0xb6, 0x07, 0xda, 0x7f, 0x78, 0x08, 0xc5, 0x26, 0x35, 0xeb,
	0x03, 0x73, 0x6c, 0xf6, 0x06, 0xed, 0xc1, 0x8d, 0x06, 0x88, 0x50, 0x32, 0xcc, 0xfe, 0x80, 0xda,
	0x37, 0x5b, 0xa6, 0xe2, 0x09, 0x60, 0xd7, 0x36, 0xda, 0xef, 0xb7, 0x68, 0xdc, 0x35, 0x07, 0x75,
	0xad, 0xf0, 0x94, 0x5b, 0xe6, 0x4d, 0x5f, 0x2b, 0x22, 0x81, 0xa3, 0xe6, 0x55, 0xbd, 0xd7, 0xda,
	0xb6, 0x1d, 0xf7, 0xcd, 0x26, 0x35, 0x07, 0x5a, 0x29, 0x72, 0xd0, 0xb1, 0x9b, 0xd6, 0xb6, 0xf5,
	0x41, 0xe4, 0x60, 0xd8, 0xdb, 0x47, 0x1a, 0x6a, 0x50, 0x48, 0x4c, 0xb5, 0xa8, 0x3d, 0xbc, 0xd6,
	0x8e, 0xa2, 0x4d, 0x5b, 0x4f, 0x31, 0x3a, 0xc6, 0x63, 0x38, 0x4c, 0x46, 0x0b, 0x12, 0x3b, 0x3a,
	0x89, 0x26, 0x3f, 0xc2, 0xdd, 0x86, 0x49, 0xfb, 0xda, 0xe9, 0xf9, 0x25, 0x14, 0xef, 0x43, 0xed,
	0x7a, 0x53, 0x8e, 0x2a, 0x64, 0xdb, 0xbd, 0x66, 0x67, 0x68, 0x98, 0x9a, 0x14, 0x09, 0xf3, 0x43,
	0x2c, 0x64, 0xcc, 0x81, 0x62, 0x50, 0xfb, 0x5a, 0x9b, 0x34, 0x9e, 0x7f, 0x7c, 0x36, 0x73, 0x82,
	0xf9, 0xe6, 0xb6, 0x3a, 0xf1, 0x16, 0x17, 0xc9, 0x0f, 0xef, 0x42, 0xfc, 0xf0, 0x26, 0x9e, 0xfb,
	0x3b, 0x00, 0x00, 0xff, 0xff, 0x61, 0x67, 0xf0, 0x69, 0x03, 0x05, 0x00, 0x00,
}
